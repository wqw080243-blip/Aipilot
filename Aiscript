-- Skynet v4+ Advanced: Full AI Autopilot with Neural Vision
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "AI Auto-Pilot SKYNET v4+",
    LoadingTitle = "Initializing Flight AI",
    LoadingSubtitle = "Advanced Neural Flight Control",
    ConfigurationSaving = { Enabled = false, FolderName = nil, FileName = "SkyNet" },
    Discord = { Enabled = false, Invite = "noinvitelink", RememberJoins = true },
    KeySystem = false
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")

-- ============ AI STATE SYSTEM ============
local AIState = {
    enabled = false,
    mode = "STANDBY",
    targetAltitude = 1000,
    targetSpeed = 300,
    engineOn = false,
    throttle = 0,
    gearDown = true,
    flaps = 0,
    spoilers = 0,
    aiThinking = "Initializing...",
    currentAction = "IDLE",
    decisionReason = "",
    flightTime = 0,
    distance = 0,
    landings = 0,
    showDebug = true,
    showMiniAIVision = true,
    -- Advanced vision system
    visionData = {
        forwardDistance = 0,
        leftDistance = 0,
        rightDistance = 0,
        upDistance = 0,
        downDistance = 0,
        obstacleMap = {},
        terrainAnalysis = "",
        windEstimate = Vector3.new(0,0,0),
        nearbyAircraft = 0,
    },
    -- Flight stability tracking
    lastPitch = 0,
    lastRoll = 0,
    pitchRate = 0,
    rollRate = 0,
    stallWarning = false,
    mouseX = 0,
    mouseY = 0,
}

local DebugParts = {}

-- ============ GUI SETUP ============
local MainTab = Window:CreateTab("üõ©Ô∏è Autopilot", 4483362458)
local StatusLabel = MainTab:CreateLabel("Status: Ready")
local ModeLabel = MainTab:CreateLabel("Mode: STANDBY")
local AltLabel = MainTab:CreateLabel("Altitude: 0ft | Speed: 0 MPH")
local ThinkingLabel = MainTab:CreateLabel("AI Thinking: Idle")
local ActionLabel = MainTab:CreateLabel("Action: IDLE")
local ReasonLabel = MainTab:CreateLabel("Reason: Waiting")

MainTab:CreateSection("Controls")
MainTab:CreateToggle({
    Name = "ü§ñ Enable Autopilot",
    CurrentValue = false,
    Callback = function(Value)
        AIState.enabled = Value
        if Value then
            StatusLabel:Set("Status: ‚úàÔ∏è AUTOPILOT ACTIVE")
            AIState.aiThinking = "Activating systems..."
        else
            StatusLabel:Set("Status: Manual")
            AIState.aiThinking = "Autopilot off"
            releaseAllInputs()
            AIState.engineOn = false
        end
    end,
})

MainTab:CreateToggle({
    Name = "üëÅÔ∏è Show AI Debug Overlay",
    CurrentValue = true,
    Callback = function(Value)
        AIState.showDebug = Value
        if not Value then
            for _, part in ipairs(DebugParts) do if part and part.Parent then part:Destroy() end end
            DebugParts = {}
        end
    end,
})

MainTab:CreateDropdown({
    Name = "Flight Mode",
    Options = {"TAKEOFF", "CLIMB", "CRUISE", "DESCENT", "LANDING", "HOLDING_PATTERN", "EMERGENCY"},
    CurrentOption = "CRUISE",
    Callback = function(Option)
        AIState.mode = Option
        ModeLabel:Set("Mode: " .. Option)
    end,
})

MainTab:CreateButton({
    Name = "üõ´ AUTO TAKEOFF SEQUENCE",
    Callback = function()
        AIState.enabled = true
        AIState.mode = "TAKEOFF"
        AIState.targetAltitude = 1500
        Rayfield:Notify({Title="Takeoff Initiated",Content="AI will handle full takeoff!",Duration=3,Image=4483362458})
    end,
})

MainTab:CreateButton({
    Name = "üõ¨ AUTO LANDING SEQUENCE",
    Callback = function()
        AIState.enabled = true
        AIState.mode = "LANDING"
        Rayfield:Notify({Title="Landing Initiated",Content="AI will handle landing!",Duration=3,Image=4483362458})
    end,
})

MainTab:CreateSection("Parameters")
MainTab:CreateSlider({
    Name="Target Altitude (ft)",Range={500,3000},Increment=100,CurrentValue=1000,
    Callback=function(v) AIState.targetAltitude=v end,
})
MainTab:CreateSlider({
    Name="Target Speed (MPH)",Range={150,450},Increment=10,CurrentValue=300,
    Callback=function(v) AIState.targetSpeed=v end,
})

-- Vision GUI with advanced sensors
local VisionTab = Window:CreateTab("üëÅÔ∏è Vision", 4483362458)
local ForwardLabel = VisionTab:CreateLabel("Forward: 0m")
local LeftLabel = VisionTab:CreateLabel("Left: 0m")
local RightLabel = VisionTab:CreateLabel("Right: 0m")
local TerrainLabel = VisionTab:CreateLabel("Terrain: 0ft")
local PitchLabel = VisionTab:CreateLabel("Pitch: 0¬∞ | Rate: 0¬∞/s")
local RollLabel = VisionTab:CreateLabel("Roll: 0¬∞ | Rate: 0¬∞/s")
local WindLabel = VisionTab:CreateLabel("Wind: None detected")
local ObstacleLabel = VisionTab:CreateLabel("Obstacles: 0")
local StallLabel = VisionTab:CreateLabel("Stall: Safe")

local StatsTab = Window:CreateTab("üìä Stats", 4483362458)
local TimeLabel = StatsTab:CreateLabel("Flight Time: 0s")
local DistLabel = StatsTab:CreateLabel("Distance: 0m")
local LandLabel = StatsTab:CreateLabel("Landings: 0")

-- ============ MINI AI VISION OVERLAY ============
local gui = Instance.new("ScreenGui")
gui.Name = "_SKYNET_AIVISION"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 420, 0, 240)
frame.Position = UDim2.new(1, -435, 1, -255)
frame.BackgroundTransparency = 0.08
frame.BackgroundColor3 = Color3.fromRGB(20,22,25)
frame.BorderSizePixel = 0
frame.Parent = gui
frame.Visible = true
_G.SKYN_AIVISION_FRAME = frame

local uicorner = Instance.new("UICorner")
uicorner.CornerRadius = UDim.new(0, 10)
uicorner.Parent = frame

-- AI Vision Header
local mainLabel = Instance.new("TextLabel")
mainLabel.Size = UDim2.new(1, -8, 0, 24)
mainLabel.Position = UDim2.new(0, 4, 0, 4)
mainLabel.BackgroundTransparency = 1
mainLabel.TextColor3 = Color3.fromRGB(100, 255, 200)
mainLabel.Font = Enum.Font.GothamBold
mainLabel.TextXAlignment = Enum.TextXAlignment.Left
mainLabel.TextScaled = true
mainLabel.Text = "ü§ñ AI PILOT NEURAL VIEW"
mainLabel.Parent = frame

-- Thinking process
local thinking = Instance.new("TextLabel", frame)
thinking.Size = UDim2.new(1, -12, 0, 32)
thinking.Position = UDim2.new(0, 6, 0, 32)
thinking.BackgroundTransparency = 1
thinking.TextColor3 = Color3.fromRGB(255, 255, 100)
thinking.Font = Enum.Font.GothamBold
thinking.TextXAlignment = Enum.TextXAlignment.Left
thinking.TextScaled = true
thinking.TextWrapped = true
thinking.Text = "üí≠ Thinking: Analyzing environment..."

-- Current action
local action = Instance.new("TextLabel", frame)
action.Size = UDim2.new(1, -12, 0, 24)
action.Position = UDim2.new(0, 6, 0, 70)
action.BackgroundTransparency = 1
action.TextColor3 = Color3.fromRGB(150, 255, 150)
action.Font = Enum.Font.GothamMedium
action.TextXAlignment = Enum.TextXAlignment.Left
action.TextScaled = true
action.TextWrapped = true
action.Text = "‚ö° Action: IDLE"

-- Decision reason
local reason = Instance.new("TextLabel", frame)
reason.Size = UDim2.new(1, -12, 0, 36)
reason.Position = UDim2.new(0, 6, 0, 98)
reason.BackgroundTransparency = 1
reason.TextColor3 = Color3.new(1,1,1)
reason.Font = Enum.Font.Gotham
reason.TextXAlignment = Enum.TextXAlignment.Left
reason.TextScaled = true
reason.TextWrapped = true
reason.Text = "üìä Reason: --"

-- Sensor readings
local sensors = Instance.new("TextLabel", frame)
sensors.Size = UDim2.new(1, -12, 0, 28)
sensors.Position = UDim2.new(0, 6, 0, 140)
sensors.BackgroundTransparency = 1
sensors.TextColor3 = Color3.fromRGB(200, 200, 255)
sensors.Font = Enum.Font.Gotham
sensors.TextXAlignment = Enum.TextXAlignment.Left
sensors.TextScaled = true
sensors.TextWrapped = true
sensors.Text = "üì° Sensors: Initializing..."

-- Flight dynamics
local dynamics = Instance.new("TextLabel", frame)
dynamics.Size = UDim2.new(1, -12, 0, 26)
dynamics.Position = UDim2.new(0, 6, 0, 172)
dynamics.BackgroundTransparency = 1
dynamics.TextColor3 = Color3.fromRGB(255, 200, 100)
dynamics.Font = Enum.Font.Gotham
dynamics.TextXAlignment = Enum.TextXAlignment.Left
dynamics.TextScaled = true
dynamics.TextWrapped = true
dynamics.Text = "‚úàÔ∏è Dynamics: Stable"

-- Decision confidence
local confidence = Instance.new("TextLabel", frame)
confidence.Size = UDim2.new(1, -12, 0, 22)
confidence.Position = UDim2.new(0, 6, 0, 202)
confidence.BackgroundTransparency = 1
confidence.TextColor3 = Color3.fromRGB(100, 255, 100)
confidence.Font = Enum.Font.GothamMedium
confidence.TextXAlignment = Enum.TextXAlignment.Left
confidence.TextScaled = true
confidence.TextWrapped = true
confidence.Text = "üéØ Confidence: 100%"

MainTab:CreateToggle({
    Name = "üñºÔ∏è Mini 'What AI Sees' Screen",
    CurrentValue = true,
    Callback = function(Value)
        frame.Visible = Value
        AIState.showMiniAIVision = Value
    end,
})

-- ============ INPUT HANDLING ============
local inputs = {W = false, S = false, G = false, B = false, F = false, R = false, Z = false, X = false}

function holdKey(key, state)
    if inputs[key] ~= state then
        inputs[key] = state
        VirtualInputManager:SendKeyEvent(state, Enum.KeyCode[key], false, game)
    end
end

function tapKey(keyCode)
    VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
    wait(0.08)
    VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
end

function releaseAllInputs()
    for key, _ in pairs(inputs) do holdKey(key, false) end
    AIState.mouseX = 0
    AIState.mouseY = 0
    local camera = Workspace.CurrentCamera
    if camera then
        local vp = camera.ViewportSize
        VirtualInputManager:SendMouseMoveEvent(vp.X/2, vp.Y/2, game)
    end
end

function setThrottle(level)
    AIState.throttle = math.clamp(level, 0, 1)
    -- Smooth throttle control - don't spam keys
    if level >= 0.95 then
        if not inputs.W then
            holdKey("W", true)
            holdKey("S", false)
        end
        AIState.currentAction = "FULL THROTTLE (100%)"
    elseif level > 0.7 then
        if not inputs.W then
            holdKey("W", true)
            holdKey("S", false)
        end
        AIState.currentAction = string.format("HIGH THROTTLE (%.0f%%)", level*100)
    elseif level > 0.4 then
        holdKey("W", false)
        holdKey("S", false)
        AIState.currentAction = string.format("CRUISE THROTTLE (%.0f%%)", level*100)
    elseif level > 0.1 then
        if not inputs.S then
            holdKey("W", false)
            holdKey("S", true)
        end
        AIState.currentAction = string.format("REDUCING THROTTLE (%.0f%%)", level*100)
    else
        holdKey("W", false)
        holdKey("S", true)
        AIState.currentAction = "IDLE THROTTLE"
    end
end

function setMouseControl(pitchInput, rollInput)
    local camera = Workspace.CurrentCamera
    if not camera then return end
    local viewport = camera.ViewportSize
    local centerX, centerY = viewport.X / 2, viewport.Y / 2
    
    -- Smooth exponential interpolation to prevent jerky movements
    AIState.mouseY = (AIState.mouseY or 0) + (pitchInput - (AIState.mouseY or 0)) * 0.18
    AIState.mouseX = (AIState.mouseX or 0) + (rollInput - (AIState.mouseX or 0)) * 0.18
    
    -- Apply scaled mouse movement
    local mouseX = centerX + (AIState.mouseX * 280)
    local mouseY = centerY + (AIState.mouseY * 280)
    
    mouseX = math.clamp(mouseX, 0, viewport.X)
    mouseY = math.clamp(mouseY, 0, viewport.Y)
    
    VirtualInputManager:SendMouseMoveEvent(math.floor(mouseX), math.floor(mouseY), game)
end

function setBrakes(active) 
    holdKey("B", active) 
end

function setGear(down)
    if AIState.gearDown ~= down then
        tapKey(Enum.KeyCode.G)
        AIState.gearDown = down
        AIState.aiThinking = down and "Gear DOWN" or "Gear UP"
        wait(0.27)
    end
end

function setFlaps(level)
    local targetFlaps = math.clamp(level, 0, 3)
    while AIState.flaps ~= targetFlaps do
        tapKey(Enum.KeyCode.F)
        if AIState.flaps < targetFlaps then
            AIState.flaps = AIState.flaps + 1
        else
            AIState.flaps = AIState.flaps - 1
        end
        wait(0.18)
    end
end

function setSpoilers(level)
    local targetSpoilers = math.clamp(level, 0, 2)
    while AIState.spoilers ~= targetSpoilers do
        tapKey(Enum.KeyCode.R)
        if AIState.spoilers < targetSpoilers then
            AIState.spoilers = AIState.spoilers + 1
        else
            AIState.spoilers = AIState.spoilers - 1
        end
        wait(0.18)
    end
end

function useRudder(direction)
    -- direction: -1 = left (Z), 1 = right (X), 0 = center
    if direction < -0.1 then
        holdKey("Z", true)
        holdKey("X", false)
    elseif direction > 0.1 then
        holdKey("Z", false)
        holdKey("X", true)
    else
        holdKey("Z", false)
        holdKey("X", false)
    end
end

-- ============ VISION SYSTEM ============
local function createDebugRay(origin, direction, color)
    if not AIState.showDebug then return end
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false
    part.Material = Enum.Material.Neon
    part.Color = color
    part.Size = Vector3.new(0.3,0.3,direction.Magnitude)
    part.CFrame = CFrame.new(origin + direction/2, origin + direction)
    part.Transparency = 0.4
    part.Parent = Workspace
    table.insert(DebugParts, part)
    Debris:AddItem(part, 0.13)
end

function scanEnvironment(position, lookVector, rightVector, upVector)
    local vision = AIState.visionData
    vision.obstacleMap = {}
    
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {Players.LocalPlayer.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    -- Forward scan (primary navigation)
    local forwardDist = 1000
    for dist = 200, forwardDist, 200 do
        local dir = lookVector * dist
        local ray = Workspace:Raycast(position, dir, rayParams)
        if ray then
            vision.forwardDistance = (ray.Position - position).Magnitude
            table.insert(vision.obstacleMap, {type="forward", distance=vision.forwardDistance})
            createDebugRay(position, ray.Position - position, Color3.new(1,0,0))
            break
        else
            vision.forwardDistance = dist
            createDebugRay(position, dir, Color3.new(0,1,0))
        end
    end
    
    -- Left/Right scans for spatial awareness
    local leftRay = Workspace:Raycast(position, -rightVector * 300, rayParams)
    vision.leftDistance = leftRay and (leftRay.Position - position).Magnitude or 300
    createDebugRay(position, -rightVector * math.min(vision.leftDistance, 300), 
        leftRay and Color3.new(1,0.5,0) or Color3.new(0,0.8,1))
    
    local rightRay = Workspace:Raycast(position, rightVector * 300, rayParams)
    vision.rightDistance = rightRay and (rightRay.Position - position).Magnitude or 300
    createDebugRay(position, rightVector * math.min(vision.rightDistance, 300), 
        rightRay and Color3.new(1,0.5,0) or Color3.new(0,0.8,1))
    
    -- Up scan for overhead obstacles
    local upRay = Workspace:Raycast(position, upVector * 500, rayParams)
    vision.upDistance = upRay and (upRay.Position - position).Magnitude or 500
    
    -- Down scan for terrain and altitude above ground
    local downRay = Workspace:Raycast(position, Vector3.new(0,-10000,0), rayParams)
    if downRay then
        vision.downDistance = (position.Y - downRay.Position.Y) * 3.28084 -- AGL in feet
        createDebugRay(position, downRay.Position - position, Color3.new(1,1,0))
        
        -- Terrain analysis
        if vision.downDistance < 200 then
            vision.terrainAnalysis = "CRITICAL - Too low!"
        elseif vision.downDistance < 500 then
            vision.terrainAnalysis = "Low altitude - caution"
        else
            vision.terrainAnalysis = "Safe altitude"
        end
    else
        vision.downDistance = 99999
        vision.terrainAnalysis = "Over water/void"
    end
    
    -- Update UI
    ForwardLabel:Set(string.format("Forward: %.0fm (%s)", vision.forwardDistance, 
        vision.forwardDistance < 200 and "‚ö†Ô∏è NEAR" or "‚úì"))
    LeftLabel:Set(string.format("Left: %.0fm", vision.leftDistance))
    RightLabel:Set(string.format("Right: %.0fm", vision.rightDistance))
    TerrainLabel:Set(string.format("AGL: %.0fft - %s", vision.downDistance, vision.terrainAnalysis))
    ObstacleLabel:Set(string.format("Obstacles: %d detected", #vision.obstacleMap))
    
    return vision
end

function getFlightData(rootPart)
    if not rootPart then return 0,0,0,0,0 end
    local velocity = rootPart.AssemblyLinearVelocity
    local speed = velocity.Magnitude * 2.23694 -- m/s to mph
    local altitude = rootPart.Position.Y * 3.28084
    
    -- Calculate pitch from velocity vector
    local pitch = 0
    if velocity.Magnitude > 1 then
        pitch = math.deg(math.asin(math.clamp(velocity.Unit.Y, -1, 1)))
    end
    
    -- Calculate pitch and roll rates
    local pitchRate = (pitch - AIState.lastPitch) * 60 -- degrees per second
    AIState.lastPitch = pitch
    AIState.pitchRate = pitchRate
    
    -- Calculate roll from orientation
    local roll = 0
    local cf = rootPart.CFrame
    local rightVector = cf.RightVector
    roll = math.deg(math.asin(math.clamp(rightVector.Y, -1, 1)))
    
    local rollRate = (roll - AIState.lastRoll) * 60
    AIState.lastRoll = roll
    AIState.rollRate = rollRate
    
    -- Calculate heading
    local heading = math.deg(math.atan2(velocity.X, velocity.Z))
    if heading < 0 then heading = heading + 360 end
    
    -- Stall warning detection
    local stallSpeed = 110 -- mph
    if speed < stallSpeed and altitude > 100 then
        AIState.stallWarning = true
        StallLabel:Set("‚ö†Ô∏è STALL WARNING - Increase speed!")
    else
        AIState.stallWarning = false
        StallLabel:Set("‚úì Stall: Safe")
    end
    
    AIState.altitude = altitude
    AIState.speed = speed
    AIState.pitch = pitch
    AIState.roll = roll
    AIState.heading = heading
    
    PitchLabel:Set(string.format("Pitch: %.1f¬∞ | Rate: %.1f¬∞/s", pitch, pitchRate))
    RollLabel:Set(string.format("Roll: %.1f¬∞ | Rate: %.1f¬∞/s", roll, rollRate))
    
    return speed, altitude, pitch, roll, heading
end

-- ============ ADVANCED AI FLIGHT MODES ============

function flyTakeoff(speed, altitude, pitch, vision, roll)
    ModeLabel:Set("Mode: üõ´ TAKEOFF")
    setGear(true)
    setFlaps(2)
    setSpoilers(0)
    setBrakes(false)
    useRudder(0)
    
    if altitude < 15 then
        -- Ground roll phase
        if speed < 110 then
            AIState.aiThinking = "Accelerating - V1 rotation speed"
            AIState.decisionReason = string.format("%.0f/110 MPH - Full power", speed)
            setThrottle(1.0)
            setMouseControl(0, -roll * 0.05) -- Keep wings level
        elseif speed >= 110 and speed < 200 then
            AIState.aiThinking = "ROTATION - Lifting off!"
            AIState.decisionReason = "VR achieved - positive rate"
            setThrottle(1.0)
            local targetPitch = 12
            local pitchError = targetPitch - pitch
            setMouseControl(-pitchError * 0.12, -roll * 0.08)
        end
    else
        -- Airborne - initial climb
        AIState.aiThinking = "Positive rate - climbing"
        AIState.decisionReason = string.format("Alt: %.0fft AGL", vision.downDistance)
        setThrottle(0.95)
        
        local targetPitch = 15
        if speed > 220 then targetPitch = 18 end
        local pitchError = targetPitch - pitch
        setMouseControl(-pitchError * 0.10, -roll * 0.12)
        
        if altitude > 400 and speed > 160 then
            setGear(false)
            AIState.aiThinking = "Gear retracting"
        end
        
        if altitude > 1000 then
            AIState.mode = "CLIMB"
            setFlaps(0)
        end
    end
end

function flyClimb(altitude, pitch, speed, roll, vision)
    ModeLabel:Set("Mode: ‚¨ÜÔ∏è CLIMB")
    setGear(false)
    setFlaps(0)
    setSpoilers(0)
    useRudder(0)
    
    local targetAlt = AIState.targetAltitude
    local altRemaining = targetAlt - altitude
    
    AIState.aiThinking = string.format("Climbing to %.0fft", targetAlt)
    AIState.decisionReason = string.format("%.0fft remaining | %.0f MPH", altRemaining, speed)
    
    -- Adjust climb rate based on remaining altitude
    local targetPitch = 15
    if altRemaining < 500 then
        targetPitch = 8 -- Shallow climb for leveling off
        AIState.aiThinking = "Approaching cruise altitude"
    end
    
    -- Speed-based throttle management
    local targetSpeed = 250
    local speedError = targetSpeed - speed
    local throttle = 0.90 + (speedError * 0.002)
    throttle = math.clamp(throttle, 0.75, 1.0)
    setThrottle(throttle)
    
    -- Pitch control with roll correction
    local pitchError = targetPitch - pitch
    setMouseControl(-pitchError * 0.11, -roll * 0.15)
    
    -- Check for obstacles during climb
    if vision.forwardDistance < 300 then
        AIState.aiThinking = "OBSTACLE AHEAD - Emergency climb!"
        AIState.decisionReason = string.format("Obstacle at %.0fm", vision.forwardDistance)
        setThrottle(1.0)
        setMouseControl(-0.7, -roll * 0.2)
    end
    
    if altitude >= targetAlt - 150 then
        AIState.mode = "CRUISE"
    end
end

function flyCruise(altitude, speed, pitch, roll, heading, vision)
    ModeLabel:Set("Mode: ‚úàÔ∏è CRUISE")
    setGear(false)
    setFlaps(0)
    setSpoilers(0)
    
    local altError = AIState.targetAltitude - altitude
    local speedError = AIState.targetSpeed - speed
    
    AIState.aiThinking = string.format("Cruising at %.0fft", altitude)
    AIState.decisionReason = string.format("Alt: %+.0fft | Speed: %.0f MPH (%+.0f)", 
        altError, speed, speedError)
    
    -- CRITICAL: Obstacle avoidance with advanced detection
    if vision.forwardDistance < 250 then
        AIState.aiThinking = "üö® OBSTACLE DETECTED - EVADING!"
        AIState.decisionReason = string.format("Obstacle %.0fm ahead - climbing", vision.forwardDistance)
        setThrottle(1.0)
        setMouseControl(-0.8, -roll * 0.25)
        return
    end
    
    -- Terrain proximity warning
    if vision.downDistance < 300 then
        AIState.aiThinking = "‚ö†Ô∏è LOW ALTITUDE WARNING!"
        AIState.decisionReason = string.format("Only %.0fft AGL - climbing", vision.downDistance)
        setThrottle(0.95)
        local targetPitch = 10
        local pitchError = targetPitch - pitch
        setMouseControl(-pitchError * 0.15, -roll * 0.18)
        return
    end
    
    -- Normal cruise operations with smooth altitude hold
    if math.abs(altError) > 200 then
        -- Significant altitude correction needed
        if altError > 0 then
            -- Need to climb
            setThrottle(0.85)
            local targetPitch = math.clamp(altError * 0.02, 3, 10)
            local pitchError = targetPitch - pitch
            setMouseControl(-pitchError * 0.13, -roll * 0.16)
        else
            -- Need to descend
            setThrottle(0.65)
            local targetPitch = math.clamp(altError * 0.02, -8, -2)
            local pitchError = targetPitch - pitch
            setMouseControl(-pitchError * 0.13, -roll * 0.16)
        end
    else
        -- Fine altitude hold
        setThrottle(0.78 + speedError * 0.0018)
        local targetPitch = altError * 0.05
        targetPitch = math.clamp(targetPitch, -3, 3)
        local pitchError = targetPitch - pitch
        setMouseControl(-pitchError * 0.14, -roll * 0.18)
    end
    
    -- Stall recovery
    if AIState.stallWarning then
        AIState.aiThinking = "‚ö†Ô∏è STALL RECOVERY!"
        AIState.decisionReason = "Speed too low - descending for airspeed"
        setThrottle(1.0)
        setMouseControl(0.3, -roll * 0.2)
    end
    
    -- Use rudder for minor heading corrections
    if math.abs(roll) > 15 then
        useRudder(-roll * 0.05)
    else
        useRudder(0)
    end
end

function flyDescent(altitude, pitch, speed, roll, vision)
    ModeLabel:Set("Mode: ‚¨áÔ∏è DESCENT")
    setGear(false)
    setFlaps(1)
    setSpoilers(0)
    
    AIState.aiThinking = "Descending for approach"
    AIState.decisionReason = string.format("Alt: %.0fft | Speed: %.0f MPH", altitude, speed)
    
    -- Gradual descent profile
    local targetPitch = -5
    if altitude < 1500 then
        targetPitch = -3
        AIState.aiThinking = "Reducing descent rate"
    end
    
    setThrottle(0.6)
    local pitchError = targetPitch - pitch
    setMouseControl(-pitchError * 0.13, -roll * 0.16)
    
    if altitude < 600 then
        AIState.mode = "LANDING"
    end
end

function flyLanding(altitude, speed, pitch, roll, vision)
    ModeLabel:Set("Mode: üõ¨ LANDING")
    setGear(true)
    setFlaps(3)
    setSpoilers(0)
    useRudder(-roll * 0.03)
    
    if altitude > 250 then
        -- Final approach
        AIState.aiThinking = "On final approach"
        AIState.decisionReason = string.format("%.0fft to touchdown | %.0f MPH", altitude, speed)
        setThrottle(0.55)
        local targetPitch = -4
        local pitchError = targetPitch - pitch
        setMouseControl(-pitchError * 0.16, -roll * 0.20)
        
    elseif altitude > 80 then
        -- Short final
        AIState.aiThinking = "Short final - stabilizing"
        AIState.decisionReason = string.format("%.0fft AGL", vision.downDistance)
        setThrottle(0.45)
        local targetPitch = -3
        local pitchError = targetPitch - pitch
        setMouseControl(-pitchError * 0.18, -roll * 0.22)
        
    elseif altitude > 30 then
        -- Flare preparation
        AIState.aiThinking = "Preparing to flare"
        AIState.decisionReason = "Reducing descent rate"
        setThrottle(0.30)
        local targetPitch = 0
        local pitchError = targetPitch - pitch
        setMouseControl(-pitchError * 0.20, -roll * 0.25)
        
    elseif altitude > 10 then
        -- FLARE
        AIState.aiThinking = "üõ¨ FLARING!"
        AIState.decisionReason = "Final flare for touchdown"
        setThrottle(0.18)
        local targetPitch = 5
        local pitchError = targetPitch - pitch
        setMouseControl(-pitchError * 0.22, -roll * 0.25)
        
    else
        -- TOUCHDOWN
        AIState.aiThinking = "‚úÖ TOUCHDOWN!"
        AIState.decisionReason = "On ground - braking"
        setThrottle(0)
        setSpoilers(2)
        setBrakes(true)
        setMouseControl(0.08, -roll * 0.15)
        
        if speed < 45 then
            AIState.landings = AIState.landings + 1
            AIState.mode = "CRUISE"
            AIState.targetAltitude = 1500
            setBrakes(false)
            setSpoilers(0)
            Rayfield:Notify({
                Title = "‚úÖ Landing Complete!",
                Content = string.format("Total Landings: %d", AIState.landings),
                Duration = 4,
                Image = 4483362458
            })
        end
    end
end

function flyHoldingPattern(altitude, speed, pitch, roll, heading, vision)
    ModeLabel:Set("Mode: ‚≠ï HOLDING PATTERN")
    setGear(false)
    setFlaps(0)
    setSpoilers(0)
    
    AIState.aiThinking = "Flying holding pattern"
    AIState.decisionReason = string.format("Circling at %.0fft", altitude)
    
    -- Maintain altitude
    local altError = AIState.targetAltitude - altitude
    setThrottle(0.70)
    
    local targetPitch = altError * 0.05
    targetPitch = math.clamp(targetPitch, -3, 3)
    local pitchError = targetPitch - pitch
    
    -- Constant gentle turn
    local targetRoll = 15 -- Banking turn
    local rollError = targetRoll - roll
    setMouseControl(-pitchError * 0.14, rollError * 0.12)
    
    useRudder(roll * 0.04)
end

function flyEmergency(altitude, speed, pitch, roll, vision)
    ModeLabel:Set("Mode: üö® EMERGENCY")
    setGear(false)
    setFlaps(1)
    setSpoilers(2)
    
    AIState.aiThinking = "üö® EMERGENCY DESCENT!"
    AIState.decisionReason = "Rapid controlled descent"
    
    setThrottle(0.30)
    local targetPitch = -15
    local pitchError = targetPitch - pitch
    setMouseControl(-pitchError * 0.20, -roll * 0.25)
    
    if altitude < 800 then
        AIState.mode = "LANDING"
        Rayfield:Notify({
            Title = "Transitioning to Landing",
            Content = "Emergency descent complete",
            Duration = 3,
            Image = 4483362458
        })
    end
end

-- ============ MINI OVERLAY UPDATER ============
RunService.Heartbeat:Connect(function()
    thinking.Text = "üí≠ " .. (AIState.aiThinking or "Idle")
    action.Text = "‚ö° " .. (AIState.currentAction or "IDLE")
    reason.Text = "üìä " .. (AIState.decisionReason or "--")
    
    -- Sensor data display
    local v = AIState.visionData
    sensors.Text = string.format("üì° Fwd: %.0fm | L: %.0fm | R: %.0fm | AGL: %.0fft", 
        v.forwardDistance or 0, v.leftDistance or 0, v.rightDistance or 0, v.downDistance or 0)
    
    -- Flight dynamics display
    dynamics.Text = string.format("‚úàÔ∏è Pitch: %.1f¬∞ (%.1f¬∞/s) | Roll: %.1f¬∞ (%.1f¬∞/s) | Throttle: %.0f%%",
        AIState.pitch or 0, AIState.pitchRate or 0, AIState.roll or 0, AIState.rollRate or 0, 
        (AIState.throttle or 0) * 100)
    
    -- Decision confidence based on data quality
    local conf = 100
    if (v.forwardDistance or 0) < 200 then conf = conf - 20 end
    if (v.downDistance or 0) < 200 then conf = conf - 15 end
    if AIState.stallWarning then conf = conf - 30 end
    if math.abs(AIState.roll or 0) > 20 then conf = conf - 10 end
    conf = math.clamp(conf, 0, 100)
    
    local confColor = conf > 80 and Color3.fromRGB(100,255,100) or 
                      conf > 50 and Color3.fromRGB(255,255,100) or 
                      Color3.fromRGB(255,100,100)
    confidence.TextColor3 = confColor
    confidence.Text = string.format("üéØ Confidence: %.0f%% | Mode: %s", conf, AIState.mode or "STANDBY")
    
    frame.Visible = (AIState.showMiniAIVision == nil or AIState.showMiniAIVision) and AIState.enabled
end)

-- ============ MAIN AI CONTROL LOOP ============
local lastUpdate = tick()
RunService.Heartbeat:Connect(function()
    local now = tick()
    local dt = now - lastUpdate
    if dt < 0.025 then return end -- 40 FPS update rate
    lastUpdate = now
    
    local player = Players.LocalPlayer
    local char = player.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    local camera = Workspace.CurrentCamera
    if not camera then return end
    
    local speed, altitude, pitch, roll, heading = getFlightData(root)
    AltLabel:Set(string.format("Altitude: %.0fft | Speed: %.0f MPH", altitude, speed))
    ThinkingLabel:Set("AI: " .. AIState.aiThinking)
    ActionLabel:Set("Action: " .. AIState.currentAction)
    ReasonLabel:Set("Reason: " .. AIState.decisionReason)
    
    AIState.flightTime = AIState.flightTime + dt
    AIState.distance = AIState.distance + (root.AssemblyLinearVelocity.Magnitude * dt)
    TimeLabel:Set(string.format("Flight Time: %.0fs", AIState.flightTime))
    DistLabel:Set(string.format("Distance: %.0fm", AIState.distance))
    LandLabel:Set(string.format("Landings: %d", AIState.landings))
    
    if not AIState.enabled then
        releaseAllInputs()
        return
    end
    
    -- ENGINE START LOGIC (only once at beginning)
    if not AIState.engineOn then
        AIState.currentAction = "üîß STARTING ENGINE"
        AIState.aiThinking = "Starting engine system..."
        AIState.decisionReason = "Engine required for flight"
        StatusLabel:Set("Status: ‚õΩ Starting engine")
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
        wait(0.15)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
        wait(0.6)
        AIState.engineOn = true
        AIState.currentAction = "‚úÖ ENGINE ONLINE"
        StatusLabel:Set("Status: ‚úàÔ∏è Engine Running")
        AIState.aiThinking = "Engine started successfully"
        return
    end
    
    -- ADVANCED ENVIRONMENTAL SCANNING
    local cf = root.CFrame
    local lookVector = cf.LookVector
    local rightVector = cf.RightVector
    local upVector = cf.UpVector
    local vision = scanEnvironment(root.Position, lookVector, rightVector, upVector)
    
    -- INTELLIGENT MODE SWITCHING BASED ON CONDITIONS
    -- Auto-switch from cruise if too low
    if AIState.mode == "CRUISE" and altitude < 400 then
        AIState.mode = "CLIMB"
        AIState.aiThinking = "Auto-switching to climb - altitude too low"
    end
    
    -- Execute flight mode
    if AIState.mode == "TAKEOFF" then
        flyTakeoff(speed, altitude, pitch, vision, roll)
    elseif AIState.mode == "CLIMB" then
        flyClimb(altitude, pitch, speed, roll, vision)
    elseif AIState.mode == "CRUISE" then
        flyCruise(altitude, speed, pitch, roll, heading, vision)
    elseif AIState.mode == "DESCENT" then
        flyDescent(altitude, pitch, speed, roll, vision)
    elseif AIState.mode == "LANDING" then
        flyLanding(altitude, speed, pitch, roll, vision)
    elseif AIState.mode == "HOLDING_PATTERN" then
        flyHoldingPattern(altitude, speed, pitch, roll, heading, vision)
    elseif AIState.mode == "EMERGENCY" then
        flyEmergency(altitude, speed, pitch, roll, vision)
    else
        -- Default to cruise if mode unknown
        AIState.mode = "CRUISE"
    end
end)

Rayfield:Notify({
    Title = "‚úàÔ∏è SKYNET v4+ Flight AI Ready!",
    Content = "Advanced Neural Autopilot Active!",
    Duration = 5,
    Image = 4483362458,
})
